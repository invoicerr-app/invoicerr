# Multi-Tenant Dynamic Numbering System - Backend Analysis

**Date:** 2026-02-04  
**Agent:** Backend Exploration Agent  
**Status:** Analysis Complete

---

## EXECUTIVE SUMMARY

This document provides a comprehensive analysis of the existing backend implementation in Invoicerr, focusing on the current numbering system, compliance infrastructure, and integration points for the new Multi-Tenant Dynamic Numbering system.

---

## 1. CURRENT DOCUMENT CREATION FLOW

### 1.1 Invoice Creation Flow

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/invoices/invoices.service.ts`

```
1. User requests invoice creation
2. Verify client belongs to company (multi-tenant check)
3. Build compliance context (country, VAT, identifiers)
4. Resolve compliance rules
5. Calculate VAT using compliance engine
6. Create invoice record in database
7. Prisma extension auto-generates rawNumber via formatPattern()
8. Dispatch webhook events
```

**Key Code Section (Lines 132-243):**

```typescript
async createInvoice(companyId: string, body: CreateInvoiceDto) {
  // ... validation code ...
  
  // Build compliance context and resolve rules
  const context = await this.complianceService.buildContext({
    company: { countryCode: supplierCountryCode, ... },
    client: { ... },
    items: items.map((i) => ({ type: i.type })),
  });

  const rules = this.complianceService.resolveRules(context);
  
  // Calculate VAT using compliance engine
  const vatResult = this.complianceService.calculateVAT(...);

  const invoice = await prisma.invoice.create({
    data: {
      // ... invoice data ...
      totalHT: vatResult.totalHT,
      totalVAT: vatResult.totalVAT,
      totalTTC: vatResult.totalTTC,
      items: { create: items.map(...) },
    },
    include: { items: true, client: true, company: true },
  });
  
  // rawNumber is auto-generated by Prisma extension
  return invoice;
}
```

### 1.2 Quote Creation Flow

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/quotes/quotes.service.ts`

Similar to invoices but simpler VAT calculation (lines 132-222). Uses direct calculation instead of compliance engine.

### 1.3 Receipt Creation Flow

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/receipts/receipts.service.ts`

Receipts are created from invoices (lines 174-231). No rawNumber generation during creation - handled by Prisma extension.

---

## 2. CURRENT NUMBERING SYSTEM

### 2.1 Prisma Extension (Automatic Numbering)

**File:** `/home/impre/Projects/invoicerr/backend/src/prisma/prisma.service.ts` (Lines 10-141)

The current system uses a Prisma Client extension to automatically generate formatted numbers:

```typescript
const prisma = new PrismaClient({ adapter }).$extends({
  query: {
    $allModels: {
      async create({ model, args, query }) {
        const result = await query(args);
        
        if (['Quote', 'Invoice', 'Receipt'].includes(model)) {
          if (!typedResult.rawNumber) {
            const formattedNumber = await formatPattern(
              model.toLowerCase() as 'quote' | 'invoice' | 'receipt',
              typedResult.number,  // Auto-increment from database
              typedResult.createdAt,
            );
            await prisma[model.toLowerCase()].update({
              where: { id: result.id },
              data: { rawNumber: formattedNumber },
            });
          }
        }
        return result;
      },
    },
  },
});
```

### 2.2 formatPattern Function

**File:** `/home/impre/Projects/invoicerr/backend/src/utils/pdf.ts` (Lines 9-58)

```typescript
type PatternType = 'receipt' | 'invoice' | 'quote';

export async function formatPattern(
  type: PatternType,
  number: number,
  date: Date = new Date(),
): Promise<string> {
  const company = await prisma.company.findFirst();
  if (!company) {
    throw new BadRequestException('No company found. Please create a company first.');
  }
  
  let pattern = '';
  let startingNumber = 1;
  switch (type) {
    case 'receipt':
      pattern = company.receiptNumberFormat;
      startingNumber = company.receiptStartingNumber;
      break;
    case 'invoice':
      pattern = company.invoiceNumberFormat;
      startingNumber = company.invoiceStartingNumber;
      break;
    case 'quote':
      pattern = company.quoteNumberFormat;
      startingNumber = company.quoteStartingNumber;
      break;
  }
  
  return pattern.replace(/\{(\w+)(?::(\d+))?\}/g, (_, key, padding) => {
    // Handles: {year}, {month}, {day}, {number:padding}
    // Example: "INV-{year}-{number:4}" => "INV-2025-0001"
  });
}
```

### 2.3 Company Numbering Configuration

**File:** `/home/impre/Projects/invoicerr/backend/prisma/schema.prisma` (Lines 317-322)

```prisma
model Company {
  // ... other fields ...
  
  quoteStartingNumber   Int    @default(1)
  quoteNumberFormat     String @default("Q-{year}-{number:4}")  // Ex: "Q-2025-0001"
  invoiceStartingNumber Int    @default(1)
  invoiceNumberFormat   String @default("INV-{year}-{number:4}") // Ex: "INV-2025-0001"
  receiptStartingNumber Int    @default(1)
  receiptNumberFormat   String @default("REC-{year}-{number:4}") // Ex: "REC-2025-0001"
  
  // ... relations ...
}
```

### 2.4 Document Models

**File:** `/home/impre/Projects/invoicerr/backend/prisma/schema.prisma`

```prisma
model Quote {
  id              String      @id @default(uuid())
  number          Int         @default(autoincrement())  // Database auto-increment
  rawNumber       String?     // Formatted number (INV-2025-0001)
  // ... other fields ...
}

model Invoice {
  id                 String    @id @default(uuid())
  number             Int       @default(autoincrement())
  rawNumber          String?   // Formatted number
  // ... other fields ...
}

model Receipt {
  id              String   @id @default(cuid())
  number          Int      @default(autoincrement())
  rawNumber       String?  // Formatted number
  // ... other fields ...
}
```

---

## 3. EXISTING COMPLIANCE INFRASTRUCTURE

### 3.1 NumberingService

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/compliance/services/numbering.service.ts`

An advanced numbering service already exists with the following capabilities:

#### Key Features:
- **Sequence Management**: Tracks lastSequence per company/series/documentType
- **Reset Periods**: Supports yearly, monthly, or never reset
- **Series Support**: Multi-series numbering (e.g., A/24/00001)
- **Hash Chain Integration**: Stores lastHash for compliance
- **Gap Detection**: Can detect gaps in numbering sequences
- **Number Reservation**: For draft documents

#### Database Model:

**File:** `/home/impre/Projects/invoicerr/backend/prisma/schema.prisma` (Lines 1011-1026)

```prisma
model NumberingSequence {
  id           String   @id @default(cuid())
  companyId    String
  series       String?
  documentType String   @default("invoice") // invoice, quote, receipt
  lastSequence Int      @default(0)
  lastHash     String?
  year         Int
  month        Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([companyId, series, documentType])
  @@index([companyId])
}
```

#### Key Methods:

```typescript
export class NumberingService {
  // Generate next number with atomic transaction
  async generateNext(context: NumberingContext, config: NumberingConfig): Promise<GeneratedNumber>
  
  // Validate number format against regex
  validateFormat(number: string, config: NumberingConfig): boolean
  
  // Check for gaps in sequence
  async checkForGaps(companyId: string, series: string, existingNumbers: number[]): Promise<number[]>
  
  // Hash chain support
  async getLastHash(context: NumberingContext): Promise<string | undefined>
  async setLastHash(context: NumberingContext, hash: string): Promise<void>
  
  // Draft document support
  async reserveNumber(context: NumberingContext, config: NumberingConfig): Promise<GeneratedNumber>
  async releaseNumber(context: NumberingContext, sequence: number): Promise<void>
  
  // Get current state
  async getState(context: NumberingContext): Promise<NumberingState>
}
```

### 3.2 HashChainService

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/compliance/services/hash-chain.service.ts`

Implements cryptographic hash chaining for compliance (Spain Veri*Factu, Portugal SAF-T):

```typescript
export class HashChainService {
  // Spain Veri*Factu style hash
  generateHashSpain(input: HashInput, config: NumberingConfig): HashResult
  
  // Portugal SAF-T style hash with RSA signature
  generateHashPortugal(input: HashInput, privateKeyPem?: string): HashResult
  
  // Generic hash generation
  generateHash(input: HashInput, config: NumberingConfig): HashResult
  
  // Chain validation
  async validateChainLinks(invoices: Array<{hash, previousHash, sequence}>): Promise<ChainValidationResult>
  async validateChain(invoices: Array<HashInput & {hash, sequence}>): Promise<ChainValidationResult>
  validateSingleHash(invoice: HashInput & {hash}, config: NumberingConfig): { valid: boolean }
}
```

### 3.3 Country Configuration

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/compliance/interfaces/numbering.interface.ts`

```typescript
export interface NumberingConfig {
  seriesRequired: boolean;       // Are series required (Spain, Portugal)
  seriesRegistration: boolean;   // Must series be registered with tax authority
  seriesFormat?: string;         // Regex format for series
  hashChaining: boolean;         // Is hash chaining required
  hashAlgorithm?: string;        // SHA-256, SHA-1, etc.
  hashFields?: string[];         // Fields included in hash
  gapAllowed: boolean;           // Are gaps allowed in numbering
  resetPeriod: 'never' | 'yearly' | 'monthly';
  platformAssigned?: boolean;    // For clearance models
  platformIdField?: string;
  platformIdFormat?: string;
}
```

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/compliance/configs/generic.config.ts`

```typescript
export const genericConfig: Omit<CountryConfig, 'code'> = {
  // ... other config ...
  
  numbering: {
    seriesRequired: false,
    seriesRegistration: false,
    hashChaining: false,
    gapAllowed: true,
    resetPeriod: 'never',
  },
  
  // ... other config ...
};
```

### 3.4 ComplianceService Integration

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/compliance/compliance.service.ts`

The compliance service provides:
- Context building
- Rule resolution
- VAT calculation
- Document generation
- Transmission services

---

## 4. MULTI-TENANT ARCHITECTURE

### 4.1 Company Guard

**File:** `/home/impre/Projects/invoicerr/backend/src/guards/company.guard.ts`

```typescript
@Injectable()
export class CompanyGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    // Extract companyId from:
    // 1. X-Company-Id header (preferred)
    // 2. Route parameter :companyId
    // 3. Query parameter ?companyId=
    
    // Verify user belongs to company
    // Attach CompanyContext to request
    const companyContext: CompanyContext = {
      companyId: userCompany.companyId,
      company: userCompany.company,
      userCompany,
      role: userCompany.role,
    };
    request.companyContext = companyContext;
  }
}
```

### 4.2 Company Service

**File:** `/home/impre/Projects/invoicerr/backend/src/modules/company/company.service.ts`

- Multi-company support
- User-Company relationships with roles (OWNER, ADMIN, ACCOUNTANT)
- PDF configuration management
- Email template management

---

## 5. INTEGRATION POINTS WITH NEW NUMBERING SYSTEM

### 5.1 Current System Limitations

1. **Single Sequence Per Document Type**: Cannot support multiple series
2. **Simple Auto-Increment**: Uses database autoincrement, not compliance-aware sequences
3. **No Gap Detection**: Cannot detect or report numbering gaps
4. **No Hash Chaining**: Not integrated with HashChainService
5. **Format Only**: Pattern-based formatting only, no sequence management
6. **No Draft Support**: Cannot reserve/release numbers for drafts
7. **Company-Level Only**: No per-series or per-year sequences

### 5.2 Integration Strategy

#### Option A: Replace Prisma Extension (Recommended)

Replace the Prisma extension with explicit NumberingService calls:

```typescript
// NEW APPROACH in invoices.service.ts
async createInvoice(companyId: string, body: CreateInvoiceDto) {
  // ... validation ...
  
  // Get country-specific numbering config
  const countryCode = this.extractCountryCode(company.country);
  const config = this.complianceService.getConfig(countryCode);
  
  // Generate number using NumberingService
  const numberingContext: NumberingContext = {
    companyId,
    documentType: 'invoice',
    series: body.series, // Optional series
  };
  
  const generatedNumber = await this.numberingService.generateNext(
    numberingContext,
    config.numbering,
  );
  
  // Generate hash if required
  let hash: string | undefined;
  if (config.numbering.hashChaining) {
    const lastHash = await this.numberingService.getLastHash(numberingContext);
    hash = this.hashChainService.generateHash({
      invoiceNumber: generatedNumber.fullNumber,
      issueDate: new Date().toISOString(),
      totalTTC: vatResult.totalTTC,
      supplierNIF: extractVAT(companyIdentifiers) || '',
      previousHash: lastHash || '0',
    }, config.numbering).hash;
  }
  
  // Create invoice with pre-generated number
  const invoice = await prisma.invoice.create({
    data: {
      number: generatedNumber.sequence,
      rawNumber: generatedNumber.fullNumber,
      hash: hash, // Store hash for chaining
      // ... other fields ...
    },
  });
  
  // Update last hash
  if (hash) {
    await this.numberingService.setLastHash(numberingContext, hash);
  }
  
  return invoice;
}
```

#### Option B: Hybrid Approach (Backward Compatible)

Keep Prisma extension for simple cases, use NumberingService for complex ones:

```typescript
// In Prisma extension, check if company uses advanced numbering
async create({ model, args, query }) {
  const company = await prisma.company.findUnique({ 
    where: { id: args.data.companyId } 
  });
  
  // If company uses advanced numbering, skip auto-generation
  if (company?.useAdvancedNumbering) {
    return query(args); // Number already set by service
  }
  
  // Otherwise, use existing formatPattern logic
  // ... existing code ...
}
```

### 5.3 Required Schema Changes

Add to `Invoice`, `Quote`, `Receipt` models:

```prisma
model Invoice {
  // ... existing fields ...
  
  // New fields for advanced numbering
  series        String?   // Document series (e.g., "A", "B")
  hash          String?   // Hash for hash chaining
  previousHash  String?   // Previous document hash
  sequence      Int?      // Sequence within series/year
  
  // For gap detection
  isDeleted     Boolean   @default(false) // Soft delete flag
  deletedAt     DateTime? // When document was deleted
}
```

---

## 6. REFACTORING RECOMMENDATIONS

### 6.1 High Priority

1. **Integrate NumberingService into Document Creation**
   - Modify `InvoicesService.createInvoice()`
   - Modify `QuotesService.createQuote()`
   - Modify `ReceiptsService.createReceipt()`

2. **Add Series Support to DTOs**
   ```typescript
   export class CreateInvoiceDto {
     // ... existing fields ...
     series?: string;  // Optional series identifier
   }
   ```

3. **Update Prisma Schema**
   - Add series, hash, previousHash fields
   - Add soft delete support for gap detection

### 6.2 Medium Priority

4. **Add Gap Detection API**
   ```typescript
   // In compliance controller
   @Get('numbering/gaps/:companyId')
   async detectGaps(@Param('companyId') companyId: string) {
     return this.numberingService.checkForGaps(companyId, ...);
   }
   ```

5. **Add Numbering State API**
   ```typescript
   @Get('numbering/state/:companyId')
   async getState(@Param('companyId') companyId: string) {
     return this.numberingService.getState({ companyId, ... });
   }
   ```

### 6.3 Low Priority

6. **Migrate Existing Data**
   - Populate NumberingSequence records for existing companies
   - Backfill sequence numbers from existing documents

7. **Remove/Deprecate Prisma Extension**
   - Once all services use NumberingService explicitly

---

## 7. POTENTIAL CHALLENGES

### 7.1 Data Migration

**Challenge:** Existing documents don't have sequence numbers or series.

**Solution:**
```typescript
// Migration script
const invoices = await prisma.invoice.findMany();
for (const invoice of invoices) {
  const year = invoice.createdAt.getFullYear();
  const sequence = invoice.number; // Use existing auto-increment
  
  await prisma.invoice.update({
    where: { id: invoice.id },
    data: { sequence, year },
  });
  
  // Update or create NumberingSequence record
  await prisma.numberingSequence.upsert({
    where: { companyId_series_documentType: { ... } },
    update: { lastSequence: Math.max(existing, sequence) },
    create: { ... },
  });
}
```

### 7.2 Concurrent Number Generation

**Challenge:** Race conditions when generating numbers.

**Solution:** Already handled by NumberingService using Prisma transactions:
```typescript
const result = await this.prisma.$transaction(async (tx) => {
  // Atomic find/upsert
  let sequenceRecord = await tx.numberingSequence.findUnique({...});
  // ...
  sequenceRecord = await tx.numberingSequence.upsert({...});
  return { sequence, sequenceRecord };
});
```

### 7.3 Backward Compatibility

**Challenge:** Existing companies expect formatPattern behavior.

**Solution:**
- Keep existing format fields in Company model
- Add `useAdvancedNumbering` flag
- Provide migration path in UI

### 7.4 Hash Chain Validation

**Challenge:** Validating chains across soft-deleted documents.

**Solution:**
- Include soft-deleted documents in chain validation
- Mark gaps in audit trail

### 7.5 Series Management

**Challenge:** Countries like Spain/Portugal require series registration.

**Solution:**
```typescript
// Add to ComplianceSettings model
model ComplianceSettings {
  // ... existing fields ...
  
  // Series registration (Spain/Portugal)
  registeredSeries Json? @default("[]") // Array of {series, registeredAt, authorityId}
}
```

---

## 8. CODE EXAMPLES

### 8.1 Current vs Proposed: Invoice Creation

**Current Implementation:**
```typescript
// invoices.service.ts - Current
async createInvoice(companyId: string, body: CreateInvoiceDto) {
  // Validation...
  
  const invoice = await prisma.invoice.create({
    data: { /* ... */ },
  });
  
  // rawNumber generated by Prisma extension using formatPattern
  return invoice;
}
```

**Proposed Implementation:**
```typescript
// invoices.service.ts - Proposed
async createInvoice(companyId: string, body: CreateInvoiceDto) {
  // Validation...
  
  // Get compliance config
  const countryCode = this.extractCountryCode(company.country);
  const config = this.complianceService.getConfig(countryCode);
  
  // Generate number with compliance rules
  const context: NumberingContext = {
    companyId,
    documentType: 'invoice',
    series: body.series,
    year: new Date().getFullYear(),
    month: new Date().getMonth() + 1,
  };
  
  const generatedNumber = await this.numberingService.generateNext(
    context,
    config.numbering,
  );
  
  // Create invoice with pre-generated number
  const invoice = await prisma.invoice.create({
    data: {
      number: generatedNumber.sequence,
      rawNumber: generatedNumber.fullNumber,
      series: generatedNumber.series,
      // ... other fields ...
    },
  });
  
  return invoice;
}
```

### 8.2 NumberingService Usage Example

```typescript
// Example: Generate next invoice number with series
const context: NumberingContext = {
  companyId: 'company-123',
  documentType: 'invoice',
  series: 'A',  // For countries requiring series
};

const config: NumberingConfig = {
  seriesRequired: true,
  seriesRegistration: true,
  resetPeriod: 'yearly',
  hashChaining: true,
  hashAlgorithm: 'SHA-256',
  gapAllowed: false,
};

const result = await numberingService.generateNext(context, config);
// Result: { number: "00001", fullNumber: "A/25/00001", sequence: 1, series: "A", year: 2025 }
```

### 8.3 Hash Chain Example

```typescript
// Example: Generate hash for Spain Veri*Factu
const lastHash = await numberingService.getLastHash(context);

const hashResult = hashChainService.generateHashSpain({
  invoiceNumber: 'A/25/00001',
  issueDate: '2025-01-15',
  totalTTC: 1210.00,
  supplierNIF: 'B12345678',
  customerNIF: 'B87654321',
  previousHash: lastHash || '0',
}, config.numbering);

// Store hash
await prisma.invoice.update({
  where: { id: invoice.id },
  data: { hash: hashResult.hash },
});

await numberingService.setLastHash(context, hashResult.hash);
```

---

## 9. FILE REFERENCES

### Core Service Files:
- `/home/impre/Projects/invoicerr/backend/src/modules/invoices/invoices.service.ts` - Invoice CRUD (1421 lines)
- `/home/impre/Projects/invoicerr/backend/src/modules/quotes/quotes.service.ts` - Quote CRUD (622 lines)
- `/home/impre/Projects/invoicerr/backend/src/modules/receipts/receipts.service.ts` - Receipt CRUD (625 lines)

### Numbering System:
- `/home/impre/Projects/invoicerr/backend/src/modules/compliance/services/numbering.service.ts` - Advanced numbering (320 lines)
- `/home/impre/Projects/invoicerr/backend/src/modules/compliance/services/hash-chain.service.ts` - Hash chaining (291 lines)
- `/home/impre/Projects/invoicerr/backend/src/utils/pdf.ts` - formatPattern function (101 lines)
- `/home/impre/Projects/invoicerr/backend/src/prisma/prisma.service.ts` - Prisma extension (219 lines)

### Configuration:
- `/home/impre/Projects/invoicerr/backend/src/modules/compliance/interfaces/numbering.interface.ts` - NumberingConfig interface (28 lines)
- `/home/impre/Projects/invoicerr/backend/src/modules/compliance/configs/generic.config.ts` - Generic country config (106 lines)
- `/home/impre/Projects/invoicerr/backend/src/modules/compliance/configs/index.ts` - Config registry (100 lines)

### Multi-Tenant:
- `/home/impre/Projects/invoicerr/backend/src/modules/company/company.service.ts` - Company management (549 lines)
- `/home/impre/Projects/invoicerr/backend/src/guards/company.guard.ts` - Multi-tenant guard (162 lines)

### Schema:
- `/home/impre/Projects/invoicerr/backend/prisma/schema.prisma` - Database schema (1028 lines)

---

## 10. CONCLUSION

The Invoicerr backend already has a sophisticated compliance infrastructure including:

1. **NumberingService** - Full-featured sequence management with transactions
2. **HashChainService** - Cryptographic hash chaining for regulations
3. **CountryConfig system** - Extensible configuration framework
4. **NumberingSequence model** - Database schema ready for advanced numbering

**Key Findings:**
- The Prisma extension currently handles basic numbering via `formatPattern()`
- NumberingService exists but is NOT currently used in document services
- Integration requires modifying create methods in Invoice/Quote/Receipt services
- Schema already supports most advanced features via NumberingSequence model

**Recommended Approach:**
1. Integrate NumberingService calls into document creation flows
2. Add series/hash fields to document models
3. Provide backward compatibility via feature flag
4. Phase out Prisma extension once migration complete

The foundation is solid - implementation mainly involves wiring existing services together.

---

*End of Analysis*
