/**
 * XML Renderer
 * Returns raw XML for e-invoicing formats
 */

import { Injectable, Logger } from '@nestjs/common';
import { IDocumentRenderer, OutputFormat, RenderOptions } from '../document.types';

@Injectable()
export class XMLRenderer implements IDocumentRenderer {
  private readonly logger = new Logger(XMLRenderer.name);

  /**
   * Render XML (passthrough - XML is already generated by builder)
   *
   * Note: This renderer expects the XML to be passed in options.xml
   * The HTML parameter is ignored for pure XML output
   */
  async render(
    _html: string,
    _format: OutputFormat,
    options?: RenderOptions,
  ): Promise<Buffer> {
    if (!options?.xml) {
      throw new Error('XML content is required for XML output format');
    }

    // Validate XML syntax
    this.validateXml(options.xml);

    // Return XML as buffer
    return Buffer.from(options.xml, 'utf-8');
  }

  /**
   * Basic XML validation
   */
  private validateXml(xml: string): void {
    // Check for XML declaration
    if (!xml.trim().startsWith('<?xml')) {
      this.logger.warn('XML does not start with XML declaration');
    }

    // Check for balanced tags (very basic)
    const openTags = (xml.match(/<[a-zA-Z][^>]*[^/]>/g) || []).length;
    const closeTags = (xml.match(/<\/[a-zA-Z][^>]*>/g) || []).length;
    const selfClosing = (xml.match(/<[a-zA-Z][^>]*\/>/g) || []).length;

    if (openTags !== closeTags + selfClosing) {
      this.logger.warn('XML may have unbalanced tags');
    }
  }

  /**
   * Format XML with indentation (for debugging)
   */
  formatXml(xml: string, indent = '  '): string {
    let formatted = '';
    let pad = 0;

    xml.split(/>\s*</).forEach((node) => {
      if (node.match(/^\/\w/)) {
        pad -= 1;
      }
      formatted += indent.repeat(pad) + '<' + node + '>\n';
      if (node.match(/^<?\w[^>]*[^/]$/) && !node.startsWith('?')) {
        pad += 1;
      }
    });

    return formatted.substring(1, formatted.length - 2);
  }
}
